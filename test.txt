// WndOpenGL.cpp : 구현 파일입니다.
//

#include "stdafx.h"
#include "Test9.h"
#include "WndOpenGL.h"


// CWndOpenGL

IMPLEMENT_DYNAMIC(CWndOpenGL, CWnd)

CWndOpenGL::CWndOpenGL()
{
	m_hRC = NULL;

	m_dX = 0;
	m_dY = 0;
	m_dZ = 0.1;
	m_dRX = m_dRY = 45;
	m_dRZ = 0;


	m_nLButtonDown = 0;
}

CWndOpenGL::~CWndOpenGL()
{
}


BEGIN_MESSAGE_MAP(CWndOpenGL, CWnd)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_WM_TIMER()
	ON_WM_PAINT()
	ON_WM_SIZE()
	ON_WM_MOUSEMOVE()
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONUP()
	ON_WM_LBUTTONDBLCLK()
	//ON_WM_MOUSEHWHEEL()
	ON_WM_MOUSEWHEEL()
	ON_WM_RBUTTONDOWN()
	ON_WM_RBUTTONUP()
END_MESSAGE_MAP()



// CWndOpenGL 메시지 처리기입니다.




int CWndOpenGL::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CWnd::OnCreate(lpCreateStruct) == -1)
		return -1;

	// TODO:  여기에 특수화된 작성 코드를 추가합니다.

	//m_rtViewPort = rtViewPort;
	RECT  rt;

	rt.left = 0;
	rt.top = 0;
	rt.right = lpCreateStruct->cx;
	rt.bottom = lpCreateStruct->cy;


	CDC *pDC = GetDC();
	HDC hdc = pDC->GetSafeHdc();
	int nWidth = rt.right - rt.left +1;
	int nHeight = rt.bottom - rt.top +1;
	static PIXELFORMATDESCRIPTOR pfd =	{
		sizeof(PIXELFORMATDESCRIPTOR),								// Size Of This Pixel Format Descriptor
		1,															// Version Number
		PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER,	// Must Support Window, Must Support OpenGL, Must Support Double Buffering
		PFD_TYPE_RGBA,												// Request An RGBA Format
		32,															// Select Our Color Depth  24
		0, 0, 0, 0, 0, 0,											// Color Bits Ignored
		0,															// No Alpha Buffer
		0,															// Shift Bit Ignored
		0,															// No Accumulation Buffer
		0, 0, 0, 0,													// Accumulation Bits Ignored
		24,															// 32Bit Z-Buffer (Depth Buffer)  
		0,															// No Stencil Buffer
		0,															// No Auxiliary Buffer
		PFD_MAIN_PLANE,												// Main Drawing Layer
		0,															// Reserved
		0, 0, 0														// Layer Masks Ignored
	};
	GLuint PixelFormat = ChoosePixelFormat(hdc, &pfd);
	SetPixelFormat(hdc,PixelFormat, &pfd);
	m_hRC = wglCreateContext(hdc);

	wglMakeCurrent(hdc, m_hRC);	
	ReleaseDC(pDC);


	glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH);
	



	return 0;
}


void CWndOpenGL::OnDestroy()
{

	wglDeleteContext(m_hRC);
	wglMakeCurrent(NULL, NULL);

	CWnd::OnDestroy();

	// TODO: 여기에 메시지 처리기 코드를 추가합니다.
}


void CWndOpenGL::OnTimer(UINT_PTR nIDEvent)
{
	// TODO: 여기에 메시지 처리기 코드를 추가 및/또는 기본값을 호출합니다.

	CWnd::OnTimer(nIDEvent);
}


void CWndOpenGL::OnSize(UINT nType, int cx, int cy)
{
	CWnd::OnSize(nType, cx, cy);

	// TODO: 여기에 메시지 처리기 코드를 추가합니다.
	glViewport( 0, 0, cx, cy );

	// 뷰잉 값 초기화. 
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();

	float m_nViewWd = cx;
	float m_nViewHi = cy;
	if( cx <= cy )
	  gluPerspective( 60 /*시야각*/, (float)cy/cx /*종횡비*/, 1.0/*앞면*/, 2000/*뒤면*/);
	else
	  gluPerspective( 60 /*시야각*/, (float)cx/cy /*종횡비*/, 1.0/*앞면*/, 2000/*뒷면*/);


	//glOrtho( -0, cx, cy, -0, -32768, 32768 );
//	glOrtho( -1.0, 1.0, -1.0, 1.0, 1.0f, 10.0f );


	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();
}


void CWndOpenGL::OnMouseMove(UINT nFlags, CPoint point)
{
	// TODO: 여기에 메시지 처리기 코드를 추가 및/또는 기본값을 호출합니다.

	CPoint  pt = point - m_ptOld;

	if( m_nLButtonDown == 1 )
	{
		m_dRX += pt.x;
		m_dRY += pt.y;

		if( m_dRY > 360 ) m_dRY = 0;
		if( m_dRY < -360 ) m_dRY = 0;

		if( m_dRX > 360 ) m_dRX = 0;
		if( m_dRX < -360 ) m_dRX = 0;


		Invalidate( FALSE );
	}
	else if( m_nLButtonDown == 2 )
	{

		m_dX += (pt.x * 0.001);
		m_dY -= (pt.y * 0.001);


		Invalidate( FALSE );
	}

	m_ptOld =  point;
	CWnd::OnMouseMove(nFlags, point);
}


void CWndOpenGL::OnLButtonDown(UINT nFlags, CPoint point)
{
	// TODO: 여기에 메시지 처리기 코드를 추가 및/또는 기본값을 호출합니다.
	m_nLButtonDown = 1;

	CWnd::OnLButtonDown(nFlags, point);
}


void CWndOpenGL::OnLButtonUp(UINT nFlags, CPoint point)
{
	// TODO: 여기에 메시지 처리기 코드를 추가 및/또는 기본값을 호출합니다.
	m_nLButtonDown = FALSE;
	CWnd::OnLButtonUp(nFlags, point);
}


void CWndOpenGL::OnRButtonDown(UINT nFlags, CPoint point)
{
	// TODO: 여기에 메시지 처리기 코드를 추가 및/또는 기본값을 호출합니다.
	m_nLButtonDown = 2;
	CWnd::OnRButtonDown(nFlags, point);
}


void CWndOpenGL::OnRButtonUp(UINT nFlags, CPoint point)
{
	// TODO: 여기에 메시지 처리기 코드를 추가 및/또는 기본값을 호출합니다.
	m_nLButtonDown = FALSE;
	CWnd::OnRButtonUp(nFlags, point);
}



void CWndOpenGL::OnLButtonDblClk(UINT nFlags, CPoint point)
{
	// TODO: 여기에 메시지 처리기 코드를 추가 및/또는 기본값을 호출합니다.
	m_dX = 0;
	m_dY = 0;
	m_dZ = 0.1;
	m_dRX = m_dRY = 0;
	Invalidate( FALSE );
	CWnd::OnLButtonDblClk(nFlags, point);
}


BOOL CWndOpenGL::OnMouseWheel(UINT nFlags, short zDelta, CPoint pt)
{
	// TODO: 여기에 메시지 처리기 코드를 추가 및/또는 기본값을 호출합니다.

	m_dZ += (zDelta * 0.001);
	if( m_dZ < -10 ) m_dZ = -10;
	else if( m_dZ > 10 ) m_dZ = 10;
	Invalidate( FALSE );

	TRACE(_T("m_dZ = %f \n"), m_dZ);
	return CWnd::OnMouseWheel(nFlags, zDelta, pt);
}


void CWndOpenGL::OnPaint()
{
	CPaintDC dc(this); // device context for painting
	// TODO: 여기에 메시지 처리기 코드를 추가합니다.
	// 그리기 메시지에 대해서는 CWnd::OnPaint()을(를) 호출하지 마십시오.

	HDC hDC = dc.GetSafeHdc();
	if( !m_hRC || !wglMakeCurrent(hDC, m_hRC) )
		return;

	glClearColor(0.1f, 0.f, 0.f, 0.f);
	glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );

	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();


	glEnable( GL_LIGHTING );
	GLfloat  lightPos[] = { 0.5f, 0.5f, 0.5f, 1.0f };
	glLightfv( GL_LIGHT0, GL_POSITION, lightPos );
	glEnable(GL_LIGHT0);
	glEnable(GL_DEPTH_TEST);// 이걸 실행하면 다른 면에 가려진 선과 면들을 보지 않는다.
	//glDisable(GL_DEPTH_TEST); //이걸 실행하면 그런거 없이 정말 그려지는 순서대로 화면에 띄운다.









	glTranslatef(m_dX, m_dY, m_dZ);

 	glRotatef(m_dRX, 1.0f, 0.0f, 0.0f);							// X축 주변으로 회전
 	glRotatef(m_dRY, 0.0f, 1.0f, 0.0f);							// Y축 주변으로 회전
 	glRotatef(m_dRZ, 0.0f, 0.0f, 1.0f);							// Z축 주변으로 회전


	OnDraw();


	glFlush();
	SwapBuffers(hDC);
	wglMakeCurrent(NULL, NULL);

}



/************************************************************************/
/*                                                                      */
/************************************************************************/


void CWndOpenGL::Draw3D()
{

	//glPushMatrix();  
	{
		double dL = 0.2;
		glBegin(GL_QUADS); 
		{
			// 앞면 
			glColor3f(1,1,0); 
			glVertex3f(-dL,-dL,-dL); 
			glVertex3f(dL,-dL,-dL); 
			glVertex3f(dL,dL,-dL); 
			glVertex3f(-dL,dL,-dL); 


			// 오른쪽 
			glColor3f(1,1,0); 
			glVertex3f(dL,dL,-dL); 
			glVertex3f(dL,dL,dL); 
			glVertex3f(dL,-dL,dL); 
			glVertex3f(dL,-dL,-dL); 

			// 왼쪽 
			glColor3f(1,0,0); 
			glVertex3f(-dL,dL,-dL); 
			glVertex3f(-dL,dL,dL); 
			glVertex3f(-dL,-dL,dL); 
			glVertex3f(-dL,-dL,-dL); 

			// 뒷면 
			glColor3f(0,1,1); 
			glVertex3f(-dL,dL,dL); 
			glVertex3f(dL,dL,dL); 
			glVertex3f(dL,-dL,dL); 
			glVertex3f(-dL,-dL,dL); 

			// 윗면 
			glColor3f(0,1,0); 
			glVertex3f(-dL,dL,-dL); 
			glVertex3f(-dL,dL,dL); 
			glVertex3f(dL,dL,dL); 
			glVertex3f(dL,dL,-dL); 

			// 밑면 
			glColor3f(0,0,1); 
			glVertex3f(-dL,-dL,-dL); 
			glVertex3f(-dL,-dL,dL); 
			glVertex3f(dL,-dL,dL); 
			glVertex3f(dL,-dL,-dL); 
		}
		glEnd();      
	}
//	glPopMatrix();
}


void CWndOpenGL::OnDraw()
{
	double  dL = 0.5;
	glBegin(GL_QUADS); 
	glColor3f(1,0,1); 
	glVertex2f(-dL,-dL); 
	glVertex2f(dL,-dL); 
	glVertex2f(dL,dL); 
	glVertex2f(-dL,dL); 
	glEnd();      
	Draw3D();

}





